#/usr/bin/env sh

################################################################################
### Helper functions
################################################################################

get_running_shell() {
    if [ -n "$ZSH_VERSION" ]; then
        echo "zsh"
    elif [ -n "$BASH_VERSION" ]; then
        echo "bash"
    elif [ -n "$fish_version" ]; then
        echo "fish"
    elif ps -p $$ -o comm= | grep -q fish; then
        echo "fish"
    elif [ -n "$KSH_VERSION" ]; then
        echo "ksh"
    elif [ -n "$FCEDIT" ]; then
        echo "ksh"
    else
        echo "unknown"
    fi
}

if [[ $(get_running_shell) = "fish" || $(get_running_shell) = "unknown" ]]; then
  return
fi

is_interactive() {
    case "$(get_running_shell)" in
        bash|zsh)
            [[ $- == *i* ]]
            ;;
        fish)
            status --is-interactive >/dev/null 2>&1
            ;;
        *)
            # Fallback for unknown shells
            case $- in
                *i*) return 0 ;;
                *) return 1 ;;
            esac
            ;;
    esac
}

is_wsl() {
    grep -qi microsoft /proc/version
}

is_exported() {
    [[ "${!1@a}" == *x* ]]
}

is_command() {
    command -v "$1" >/dev/null 2>&1
}

is_mise_command() {
    is_command mise && mise which "$1" >/dev/null 2>&1
}

is_available() {
    is_command "$1" || is_mise_command "$1"
}

export_secret () {
    local var_name=$1
    local file=$2
    if [[ -f $file ]]; then
        local content=$(cat $file)
        export "${var_name}"="$content"
    fi
}

ensure_symlink () {
    local original=$1
    local path=$2

    if [ -e "$path" ]; then
        mv "$path" "$path.old"
        return
    fi

    local original_fullpath="$(cd "$(dirname "$original")"; pwd)/$(basename "$original")"

    if [ -L "$path" ]; then
        rm "$path"
    fi

    ln -s "$original_fullpath" "$path"
}

modify_path () {
    # Check if the directory is not already in PATH
    if [[ ":$PATH:" != *":$1:"* ]]; then
        # Append or prepend the directory to PATH based on the second argument
        if [[ $2 == "prepend" ]]; then
            export PATH="$1:$PATH"
            # echo "Prepended $1 to PATH"
        else
            export PATH="$PATH:$1"
            # echo "Appended $1 to PATH"
        fi
    else
        # echo "$1 is already in PATH"
        echo ""  > /dev/null
    fi
}

################################################################################
### Environment
################################################################################

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export EDITOR='vi'
export DOTFILES=$HOME/dotfiles

if [[ $(get_running_shell) = "zsh" ]]; then
  autoload -Uz compinit && compinit
  autoload -U +X bashcompinit && bashcompinit
fi

# WSL
if is_wsl; then
    export WSL_HOST=$(awk '/nameserver / {print $2; exit}' /etc/resolv.conf 2>/dev/null)
    #export DISPLAY="$WSL_HOST:0"
    #export LIBGL_ALWAYS_INDIRECT=1

    wsl_ip () {
        ip addr show eth0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}'
    }
    export WSL_GUEST=$(wsl_ip)
fi

# Android dev
if [ -d $HOME/Android/Sdk ]; then
    export ANDROID_HOME=$HOME/Android/Sdk
    export ANDROID_SDK_ROOT=$ANDROID_HOME

    modify_path "$ANDROID_HOME/emulator" append
    modify_path "$ANDROID_HOME/platform-tools" append

    # If cmdline tools version 8.0 are installed they should have precendence,
    # because react native does not work with newer ones
    modify_path "$ANDROID_HOME/cmdline-tools/8.0/bin" append
    modify_path "$ANDROID_HOME/cmdline-tools/latest/bin" append
    modify_path "$ANDROID_HOME/cmdline-tools/11.0/bin" append
    modify_path "$ANDROID_HOME/cmdline-tools/10.0/bin" append
    modify_path "$ANDROID_HOME/cmdline-tools/9.0/bin" append

    modify_path "$ANDROID_HOME/tools" append
    modify_path "$ANDROID_HOME/tools/bin" append

    if is_exported WSL_HOST; then
        export ADB_SERVER_SOCKET=tcp:$WSL_HOST:5037
    fi
fi

# Android studio
if [ -d "$HOME/Applications/android-studio" ]; then
    export ANDROID_STUDIO=$HOME/Applications/android-studio
    ensure_symlink "$ANDROID_STUDIO/bin/studio.sh" $HOME/bin/android-studio
    modify_path "$HOME/Applications/android-studio/bin" append
fi
if [ -d "$HOME/Applications/flutter" ]; then
    modify_path "$HOME/Applications/flutter/bin" append
fi

# Rust binaries
modify_path "$HOME/.cargo/bin" prepend

# Volta nodejs version manager
if [[ -d $HOME/.volta ]]; then
    export VOLTA_HOME="$HOME/.volta"
    modify_path "$VOLTA_HOME/bin" prepend
fi

# Fly.io
export FLYCTL_INSTALL="$HOME/.fly"
modify_path "$FLYCTL_INSTALL/bin" prepend

# Locally compiled/installed files
modify_path "$HOME/.local/bin" prepend
# Home binaries (systems should do this already)
modify_path "$HOME/bin" prepend

# Flatpak paths
export XDG_DATA_DIRS=$HOME/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:$XDG_DATA_DIRS

# Krew kubectl plugin package manager
modify_path "${KREW_ROOT:-$HOME/.krew}/bin" prepend

###############################################################################
# Mise dev tool manager
###############################################################################

if is_command mise; then
  case $(get_running_shell) in
  "zsh")
    eval "$(mise activate zsh)"
    ;;
  "bash")
    eval "$(mise activate bash)"
    ;;
  "fish")
    mise activate fish | source
    ;;
  *)
    :
    ;;
  esac
fi

################################################################################
### Aliases
################################################################################

if [[ "$OSTYPE" == "linux-gnu" ]]; then
    alias ls='ls --color=auto --group-directories-first --sort=extension'
    alias update-ubuntu='sudo sh -c "apt-get update && apt-get -y upgrade && apt-get -y dist-upgrade && apt-get autoremove -y"'
    alias update-fedora='sudo sh -c "yum update -y"'
    alias update-arch='sudo sh -c "pacman -Syu --noconfirm"'
elif [[ "$OSTYPE" == "darwin"* ]]; then
    alias ls='ls -FG'
    whoishoggingport () {
        lsof -n -iTCP:$1 | grep LISTEN
    }
fi

if is_command sudo; then
  # Keep terminal info when using sudo
  alias sudo="sudo TERMINFO=\"$TERMINFO\""
fi


# If running in kitty, alias ssh to kitten ssh
if [[ "$TERM" == "xterm-kitty" ]]; then
    alias ssh='kitten ssh'
fi

alias update-npm-packages="npx npm-check-updates -i"
alias c='clear'
alias ..='cd ..'
alias back='cd "$OLDPWD"'
alias mkdir='mkdir -p -v'
alias su='sudo -i'
alias duf='du -sk * | sort -n | perl -ne '\''($s,$f)=split(m{\t});for (qw(K M G)) {if($s<1024) {printf("%.1f",$s);print "$_\t$f"; last};$s=$s/1024}'\'
alias gs='git add . && git commit -m "Sync" && git push origin'
alias erlang-version="erl -eval '{ok, Version} = file:read_file(filename:join([code:root_dir(), \"releases\", erlang:system_info(otp_release), \"OTP_VERSION\"])), io:fwrite(Version), halt().' -noshell"
alias serve-spa="npx --yes http-server-spa"
alias emacs="flatpak run org.gnu.emacs"

if is_available nvim; then
    export EDITOR='nvim'
    export VISUAL='nvim'
    alias vi='nvim'
    alias vim='nvim'
    alias vimdiff='nvim -d'
fi

alias lg='lazygit'

# Git aliases
alias gta='gitk --all'
alias gita='gitk --all'
alias gg='git gui'

# If podman is installed, use it instead of docker
if is_command podman; then
    alias docker=podman
    alias docker-compose='podman-compose'
    export DOCKER_HOST="unix:///run/podman/podman.sock"
fi

# k8s aliases
alias k='kubectl'
alias kcfg='kubectl config view --minify | grep name'
alias kc='kubectx'
alias kn='kubens'

################################################################################
### Other
################################################################################

# Dircolors
# if [[ -f $HOME/.dir_colors ]]; then
#     eval "$(dircolors $HOME/.dir_colors)"
# fi

# Enable Erlang/Elixir shell history
export ERL_AFLAGS="-kernel shell_history enabled"

# Ripgrep and fzf config
export RIPGREP_CONFIG_PATH=$HOME/.ripgreprc
export FZF_DEFAULT_COMMAND="rg --files"
export FZF_FIND_FILE_COMMAND="rg --files"

# Catppuccin frappe theme for FZF
export FZF_DEFAULT_OPTS=" \
  --color=bg+:-1,bg:-1 \
  --color=spinner:#f2d5cf,hl:#e78284 \
  --color=fg:#c6d0f5,header:#e78284,info:#ca9ee6,pointer:#f2d5cf \
  --color=marker:#f2d5cf,fg+:#c6d0f5,prompt:#ca9ee6,hl+:#e78284"

# FZF
[ -f ~/.fzf.bash ] && source ~/.fzf.bash
[[ -e "$HOME/.fzf-extras/fzf-extras.sh" ]] \
    && source "$HOME/.fzf-extras/fzf-extras.sh"

################################################################################
### Secrets
################################################################################

export_secret CR_PAT $DOTFILES/.credentials/github-token-registry
export_secret DO_PAT $DOTFILES/.credentials/digital-ocean
export_secret NPM_TOKEN_FOR_GITHUB $DOTFILES/.credentials/npm_token_for_github

################################################################################
### Other
################################################################################

# Cursor size
if is_command gsettings; then
    export XCURSOR_SIZE="$(gsettings get org.gnome.desktop.interface cursor-size)"
fi


################################################################################
### Prompt
################################################################################

if is_interactive; then
  if is_command starship; then
      eval "$(starship init $(get_running_shell))"
      eval "$(starship completions $(get_running_shell))"
  # Mise has some quirks in the way it works by default and the above will not
  # work in case it's used in non-shim mode. That is because mise waits until
  # prompt is rendered to update PATH so we have a chicken-egg problem.
  elif is_mise_command starship; then
      eval "$(mise exec starship -- starship init $(get_running_shell))"
      eval "$(mise exec starship -- starship completions $(get_running_shell))"
  fi
fi
